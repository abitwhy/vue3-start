# API 模块化管理

*这是针对前后端分离的项目而言的。*

[toc]

## What——什么是 API 模块化管理？

在前端项目中，按照**前端项目结构**（推荐）或**后端接口结构**，对接口作模块化的封装。

## Why——为什么需要？

当接口发生变化（URI 或 method），使用原始方式（即，在每个页面独立请求所需接口）会很难甚至无法重构（如：URI 字符串会被拼接，失去其唯一标识性；method 更改需要请求头相应改变等，都会导致重构任务的膨胀，并且膨胀指数上还会再添加上页面数）。

## When——什么时候需要？

当前端项目是整个应用的核心时，接口可能频繁变化，而前端系统逻辑变化相对较慢，此时重构成本大于维护成本（实际任务同样是重构，强调维护是因为引入了新的 API 模块）。
*似乎实际上这种情况极少出现，前端项目从来都是接口背后内容的附属品，并且也是最快过时的。*

## How——如何使用？

### 原则

不对接口 URI 作任何拼接，保持其唯一性，便于重构。
*之所以需要重构，是因为**前端项目结构**封装方式会产生接口冗余，下文中所提到的**全局+独立**的方式通常也无法完全避免。*

### 做法

将接口按照

- 前端项目结构
  *可能会导致接口冗余，但会呈现更清晰和统一的模块目录，适合团队同步开发。*
- 后端接口结构
  *没有冗余，意味着最小的重构代价，但增加了理成本，适合独立开发者。*

作函数封装，并模块化导出。

### 建议

针对**前端项目结构**封装方式，可考虑使用**全局+独立**的混合方式建立 API 模块：在视图页面目录建立独立 API 模块，在根目录建立全局 API 模块，收录基础或常用的 API 模块。

这样做会同时解决两个痛点：

- 无需手动保持 API 模块目录与视图目录一致
- 提供了解决接口冗余的方法（但通常完全消除冗余是不必要的）

*既然独立出来，那就又新增了页面数复杂度。*

## 结论

**绝大多数情况下没有必要做 API 模块化管理**